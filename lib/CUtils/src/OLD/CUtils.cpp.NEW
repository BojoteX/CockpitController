// CUtils.cpp
// Centralized management for controllers

#include <Arduino.h>
#include <Wire.h>
#include <cstdio> 
#include <cstring>   
#include <vector>
#include "CUtils.h"

// ‚Äî‚Äî‚Äî globals ‚Äî‚Äî‚Äî
I2CDeviceInfo  discoveredDevices[MAX_DEVICES];
uint8_t        discoveredDeviceCount = 0;

// initialize all entries to nullptr
const char*    panelNameByAddr[I2C_ADDR_SPACE] = { nullptr };

// All Controller Management is here
#include "internal/GPIO.cpp"
#include "internal/WS2812.cpp"
#include "internal/TM1637.cpp"
#include "internal/GN1640.cpp"
#include "internal/PCA9555.cpp" 

// ********************************************************
// Panel and Global meta-command handler
//
//
//
// ********************************************************

PanelID getPanelID(uint8_t address) {
  switch (address) {
    case 0x22: return PanelID::ECM;
    case 0x26: return PanelID::BRAIN;
    case 0x5B: return PanelID::ARM;
    default:   return PanelID::UNKNOWN;
  }
}

const char* panelIDToString(PanelID id) {
  switch (id) {
    case PanelID::ECM:   return "ECM Panel";
    case PanelID::BRAIN: return "Brain / IRCool Panel";
    case PanelID::ARM:   return "Master Arm Panel";
    default:             return "Unknown Panel";
  }
}

// 1) Define your three panels in one place:
struct PanelDef {
  uint8_t     addr;
  PanelID     id;
  const char* label;
};

static constexpr PanelDef kPanels[] = {
  { 0x22, PanelID::ECM,   "ECM Panel"            },
  { 0x26, PanelID::BRAIN, "Brain / IRCool Panel" },
  { 0x5B, PanelID::ARM,   "Master Arm Panel"     },
};

// 2) A data‚Äêdriven scan that only ever touches those three:
void scanConnectedPanels() {
  discoveredDeviceCount = 0;
  memset(panelNameByAddr, 0, sizeof(panelNameByAddr));

  for (auto &p : kPanels) {
    bool present = false;
    for (uint8_t attempt = 0; attempt < 3; ++attempt) {
      Wire.beginTransmission(p.addr);
      Wire.write((uint8_t)0x00);
      if (Wire.endTransmission() == 0 && Wire.requestFrom(p.addr, (uint8_t)1) == 1) {
        Wire.read();              // throw away the byte
        present = true;
        break;
      }
      delay(5);
    }
    if (!present || discoveredDeviceCount >= MAX_DEVICES) 
      continue;

    discoveredDevices[discoveredDeviceCount++] = { p.addr, p.label };
    panelNameByAddr[p.addr] = p.label;
  }
}

// 3) Rewrite your two mapping functions to use the same table:
PanelID getPanelID(uint8_t address) {
  for (auto &p : kPanels) {
    if (p.addr == address) 
      return p.id;
  }
  return PanelID::UNKNOWN;
}

const char* panelIDToString(PanelID id) {
  for (auto &p : kPanels) {
    if (p.id == id) 
      return p.label;
  }
  return "Unknown Panel";
}


bool panelExists(uint8_t targetAddr) {
  for (uint8_t i = 0; i < discoveredDeviceCount; ++i) {
    if (discoveredDevices[i].address == targetAddr) return true;
  }
  return false;
}

/*
void scanConnectedPanels() {
  // reset
  discoveredDeviceCount = 0;
  // clear direct‚Äêindex table
  memset(panelNameByAddr, 0, sizeof(panelNameByAddr));
  delay(500);     // PCA wake-up, debug-only if you guard it

  for (uint8_t addr = 0x03; addr <= 0x77; ++addr) {
    Wire.beginTransmission(addr);
    if (Wire.endTransmission() == 0 && discoveredDeviceCount < MAX_DEVICES) {
      // resolve label
      const char* label = panelIDToString(getPanelID(addr));
      // store in your array
      discoveredDevices[discoveredDeviceCount++] = { addr, label };
      // **also** populate the direct‚Äêindex lookup
      panelNameByAddr[addr] = label;
    }
  }
}
*/

void printDiscoveredPanels() {
  if (discoveredDeviceCount == 0) {
    debugPrintln("No I2C devices found.");
    return;
  }

  debugPrintln("\nüîé === Discovered I2C Devices ===");
  debugPrintln("üìã Address    | Device Description");
  debugPrintln("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ|‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ");

  for (uint8_t i = 0; i < discoveredDeviceCount; ++i) {
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "üì° 0x%02X       | %s", 
             discoveredDevices[i].address, 
             discoveredDevices[i].label);
    debugPrintln(buffer);
  }

  debugPrintln("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ\n");
}

// *****************************************************
// Panel LED Detection for DEBUGING 
// *****************************************************

// Index mapping for displayed LED menu
std::vector<int> displayedIndexes(panelLEDsCount);
int displayedCount = 0;

void printLEDMenu() {
  displayedCount = 0;  
  constexpr int columns = 3;
  constexpr int colWidth = 25;
  constexpr int bufSize = 4096;
  char buffer[bufSize];
  int cursor = 0;

  cursor += snprintf(buffer + cursor, bufSize - cursor, "\n--- LED Selection Menu ---\n\n");

  for (int i = 0; i < panelLEDsCount; i++) {
    cursor += snprintf(buffer + cursor, bufSize - cursor, "%d: %s", displayedCount, panelLEDs[i].label);

    int len = strlen(panelLEDs[i].label);
    for (int s = 0; s < colWidth - len; s++) {
      if (cursor < bufSize - 1) buffer[cursor++] = ' ';
    }

    displayedIndexes[displayedCount++] = i;

    if ((i + 1) % columns == 0 || i == panelLEDsCount - 1) {
      if (cursor < bufSize - 1) buffer[cursor++] = '\n';
    }
  }

  buffer[cursor] = '\0'; // Null-terminate
  Serial.print(buffer);

  #if DEBUG_USE_WIFI
  // #include "WiFiDebug.h"
  wifiDebugPrintln("See serial console for LED test");
  #endif
}

void handleLEDSelection() {
  while (true) {
    Serial.println("Enter LED number to activate (or press Enter to exit):");

    while (!Serial.available());
    String input = Serial.readStringUntil('\n');

    if (input.length() == 0) break;  // Exit if Enter is pressed without input

    int userSelection = input.toInt();
    if (userSelection >= 0 && userSelection < displayedCount) {
      int actualIndex = displayedIndexes[userSelection];
      Serial.print("Activating LED: ");
      Serial.printf("%s\n", panelLEDs[actualIndex].label);

      setLED(panelLEDs[actualIndex].label, true, 100);
      delay(5000);
      setLED(panelLEDs[actualIndex].label, false, 0);

      Serial.print("Deactivated LED: ");
      Serial.printf("%s\n", panelLEDs[actualIndex].label);

      // Clear the screen
      Serial.printf("\033[2J\033[H");

      printLEDMenu();
    } else {
      Serial.println("Invalid selection or unsupported LED.");
    }
  }
}

// *****************************************************
// Panel LED Detection for DEBUGING 
// *****************************************************

// Call this instead of calling DcsbiosProtocolReplay() directly
void runReplayWithPrompt() {
    bool infinite = false;

    while ( true ) {
        // 1) Run one iteration of your replay
        DcsbiosProtocolReplay();

        // 2) If we‚Äôre in ‚Äúinfinite‚Äù mode, just loop back immediately
        if ( infinite ) continue;

        // 3) Otherwise prompt the user
        Serial.println();
        Serial.println(F("=== REPLAY FINISHED ==="));
        Serial.println(F("1) One more iteration"));
        Serial.println(F("2) Run infinitely"));
        Serial.println(F("3) Quit to main program"));
        Serial.print  (F("Choose [1-3]: "));

        // 4) Wait (cooperatively) for a keypress
        while ( !Serial.available() ) {
            yield(); 
        }

        char c = Serial.read();
        // flush any extra characters (newline, etc)
        while ( Serial.available() ) {
            Serial.read();
        }
        Serial.println(c);

        // 5) Dispatch
        switch ( c ) {
          case '1':
            // just loop once more
            break;

          case '2':
            // flip into infinite mode
            infinite = true;
            Serial.println(F(">>> entering infinite replay mode <<<"));
            break;

          case '3':
            Serial.println(F(">>> exiting replay, returning to normal execution <<<"));
            return;

          default:
            Serial.println(F("Invalid choice; please enter 1, 2, or 3."));
            // re‚Äêprompt on next iteration (doesn't advance replay)
            continue;
        }
    }
}