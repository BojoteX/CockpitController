// CUtils.cpp
// Centralized management for controllers

#include <vector>
#include "CUtils.h"

// All Controller Management is here
#include "internal/GPIO.cpp"
#include "internal/WS2812.cpp"
#include "internal/TM1637.cpp"
#include "internal/GN1640.cpp"
#include "internal/PCA9555.cpp" 

// ********************************************************
// Panel and Global meta-command handler
//
//
//
// ********************************************************

enum class PanelID : uint8_t {
  ECM    	= 0x22,
  BRAIN   	= 0x26,
  ARM    	= 0x5B,
  UNKNOWN 	= 0x00
};

PanelID getPanelID(uint8_t address) {
  switch (address) {
    case 0x22: return PanelID::ECM;
    case 0x26: return PanelID::BRAIN;
    case 0x5B: return PanelID::ARM;
    default:   return PanelID::UNKNOWN;
  }
}

#define MAX_DEVICES 10

struct I2CDeviceInfo {
  uint8_t address;
  const char* label;
};

I2CDeviceInfo discoveredDevices[MAX_DEVICES];
uint8_t discoveredDeviceCount = 0;

bool panelExists(uint8_t targetAddr) {
  for (uint8_t i = 0; i < discoveredDeviceCount; ++i) {
    if (discoveredDevices[i].address == targetAddr) return true;
  }
  return false;
}

void scanConnectedPanels() {
  discoveredDeviceCount = 0;
  delay(500); // PCA wake-up time

  for (uint8_t addr = 0x03; addr <= 0x77; addr++) {
    Wire.beginTransmission(addr);
    if (Wire.endTransmission() == 0 && discoveredDeviceCount < MAX_DEVICES) {
      const char* label = nullptr;
      switch (getPanelID(addr)) {
        case PanelID::ECM:    label = "ECM Panel"; break;
        case PanelID::BRAIN:  label = "Brain / IRCool Panel"; break;
        case PanelID::ARM:    label = "Master Arm Panel"; break;
        default:              label = "Unknown Panel"; break;
      }
      discoveredDevices[discoveredDeviceCount++] = { addr, label };
    }
  }
}

void printDiscoveredPanels() {
  if (discoveredDeviceCount == 0) {
    debugPrintln("No I2C devices found.");
    return;
  }

  debugPrintln("\nðŸ”Ž === Discovered I2C Devices ===");
  debugPrintln("ðŸ“‹ Address    | Device Description");
  debugPrintln("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€|â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€");

  for (uint8_t i = 0; i < discoveredDeviceCount; ++i) {
    char buffer[64];
    snprintf(buffer, sizeof(buffer), "ðŸ“¡ 0x%02X       | %s", 
             discoveredDevices[i].address, 
             discoveredDevices[i].label);
    debugPrintln(buffer);
  }

  debugPrintln("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n");
}

// *****************************************************
// Panel LED Detection for DEBUGING 
// *****************************************************

// Index mapping for displayed LED menu
std::vector<int> displayedIndexes(panelLEDsCount);
int displayedCount = 0;

void printLEDMenu() {
  displayedCount = 0;  
  constexpr int columns = 3;
  constexpr int colWidth = 25;
  constexpr int bufSize = 4096;
  char buffer[bufSize];
  int cursor = 0;

  cursor += snprintf(buffer + cursor, bufSize - cursor, "\n--- LED Selection Menu ---\n\n");

  for (int i = 0; i < panelLEDsCount; i++) {
    cursor += snprintf(buffer + cursor, bufSize - cursor, "%d: %s", displayedCount, panelLEDs[i].label);

    int len = strlen(panelLEDs[i].label);
    for (int s = 0; s < colWidth - len; s++) {
      if (cursor < bufSize - 1) buffer[cursor++] = ' ';
    }

    displayedIndexes[displayedCount++] = i;

    if ((i + 1) % columns == 0 || i == panelLEDsCount - 1) {
      if (cursor < bufSize - 1) buffer[cursor++] = '\n';
    }
  }

  buffer[cursor] = '\0'; // Null-terminate
  Serial.print(buffer);

  #if DEBUG_USE_WIFI
  // #include "WiFiDebug.h"
  wifiDebugPrintln("See serial console for LED test");
  #endif
}

void handleLEDSelection() {
  while (true) {
    Serial.println("Enter LED number to activate (or press Enter to exit):");

    while (!Serial.available());
    String input = Serial.readStringUntil('\n');

    if (input.length() == 0) break;  // Exit if Enter is pressed without input

    int userSelection = input.toInt();
    if (userSelection >= 0 && userSelection < displayedCount) {
      int actualIndex = displayedIndexes[userSelection];
      Serial.print("Activating LED: ");
      Serial.printf("%s\n", panelLEDs[actualIndex].label);

      setLED(panelLEDs[actualIndex].label, true, 100);
      delay(5000);
      setLED(panelLEDs[actualIndex].label, false, 0);

      Serial.print("Deactivated LED: ");
      Serial.printf("%s\n", panelLEDs[actualIndex].label);

      // Clear the screen
      Serial.printf("\033[2J\033[H");

      printLEDMenu();
    } else {
      Serial.println("Invalid selection or unsupported LED.");
    }
  }
}

// *****************************************************
// Panel LED Detection for DEBUGING 
// *****************************************************

// Call this instead of calling DcsbiosProtocolReplay() directly
void runReplayWithPrompt() {
    bool infinite = false;

    while ( true ) {
        // 1) Run one iteration of your replay
        DcsbiosProtocolReplay();

        // 2) If weâ€™re in â€œinfiniteâ€ mode, just loop back immediately
        if ( infinite ) continue;

        // 3) Otherwise prompt the user
        Serial.println();
        Serial.println(F("=== REPLAY FINISHED ==="));
        Serial.println(F("1) One more iteration"));
        Serial.println(F("2) Run infinitely"));
        Serial.println(F("3) Quit to main program"));
        Serial.print  (F("Choose [1-3]: "));

        // 4) Wait (cooperatively) for a keypress
        while ( !Serial.available() ) {
            yield(); 
        }

        char c = Serial.read();
        // flush any extra characters (newline, etc)
        while ( Serial.available() ) {
            Serial.read();
        }
        Serial.println(c);

        // 5) Dispatch
        switch ( c ) {
          case '1':
            // just loop once more
            break;

          case '2':
            // flip into infinite mode
            infinite = true;
            Serial.println(F(">>> entering infinite replay mode <<<"));
            break;

          case '3':
            Serial.println(F(">>> exiting replay, returning to normal execution <<<"));
            return;

          default:
            Serial.println(F("Invalid choice; please enter 1, 2, or 3."));
            // reâ€prompt on next iteration (doesn't advance replay)
            continue;
        }
    }
}