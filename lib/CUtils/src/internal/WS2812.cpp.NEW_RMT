#include <driver/rmt.h>

CRGB leds[NUM_LEDS];
#define WS2812B_PIN 35
#define RMT_TX_CHANNEL    RMT_CHANNEL_0
#define RMT_CLK_DIV       8    // 80MHz / 8 = 10MHz tick

uint8_t pixels[NUM_LEDS * 3];
uint8_t brightness = 255;
uint32_t lastShowTime = 0;

// Predefined colors
const CRGB CRGB::Black  = {0,   0,   0  };
const CRGB CRGB::Red    = {255, 0,   0  };
const CRGB CRGB::Green  = {0,   255, 0  };
const CRGB CRGB::Blue   = {0,   0,   255};
const CRGB CRGB::Yellow = {255, 255, 0  };

void WS2812_show();

void WS2812_init() {
  // Configure pin
  pinMode(WS2812B_PIN, OUTPUT);
  digitalWrite(WS2812B_PIN, LOW);

  // Configure RMT
  rmt_config_t cfg;
  cfg.rmt_mode = RMT_MODE_TX;
  cfg.channel = RMT_TX_CHANNEL;
  cfg.gpio_num = (gpio_num_t)WS2812B_PIN;
  cfg.mem_block_num = 1;
  cfg.clk_div = RMT_CLK_DIV;
  cfg.tx_config.loop_en = false;
  cfg.tx_config.carrier_en = false;
  cfg.tx_config.idle_output_en = true;
  cfg.tx_config.idle_level = RMT_IDLE_LEVEL_LOW;
  rmt_config(&cfg);
  rmt_driver_install(RMT_TX_CHANNEL, 0, 0);

  // Clear buffer
  memset(pixels, 0, sizeof(pixels));
  brightness = 255;
  WS2812_clearAll();
}

void WS2812_setLEDColor(uint8_t ledIndex, CRGB color) {
  if (ledIndex >= NUM_LEDS) return;
  pixels[ledIndex * 3 + 0] = color.g;
  pixels[ledIndex * 3 + 1] = color.r;
  pixels[ledIndex * 3 + 2] = color.b;
  WS2812_show();
}

void WS2812_clearAll() {
  memset(pixels, 0, sizeof(pixels));
  WS2812_show();
}

void WS2812_show() {
  // Enforce reset time of >50Âµs
  uint32_t now = micros();
  if (now - lastShowTime < 50) {
    delayMicroseconds(50 - (now - lastShowTime));
  }

  // WS2812 timing: T0H=4, T0L=8, T1H=8, T1L=4 ticks @10MHz
  const uint8_t T1H = 8, T1L = 4;
  const uint8_t T0H = 4, T0L = 8;

  // Build RMT items
  static rmt_item32_t items[NUM_LEDS * 24];
  int idx = 0;
  for (int i = 0; i < NUM_LEDS; ++i) {
    uint8_t g = (pixels[i*3 + 0] * brightness) >> 8;
    uint8_t r = (pixels[i*3 + 1] * brightness) >> 8;
    uint8_t b = (pixels[i*3 + 2] * brightness) >> 8;
    uint32_t data = ((uint32_t)g << 16) | ((uint32_t)r << 8) | b;
    for (int bit = 23; bit >= 0; --bit) {
      bool one = data & (1UL << bit);
      items[idx].level0   = 1;
      items[idx].duration0 = one ? T1H : T0H;
      items[idx].level1   = 0;
      items[idx].duration1 = one ? T1L : T0L;
      idx++;
    }
  }

  // Transmit and wait
  rmt_write_items(RMT_TX_CHANNEL, items, idx, true);
  rmt_wait_tx_done(RMT_TX_CHANNEL, portMAX_DELAY);
  lastShowTime = micros();
}

void WS2812_allOn(CRGB color) {
  for (int i = 0; i < NUM_LEDS; ++i) {
    pixels[i*3 + 0] = color.g;
    pixels[i*3 + 1] = color.r;
    pixels[i*3 + 2] = color.b;
  }
  WS2812_show();
  debugPrintln("ðŸ”† WS2812 All ON");
}

void WS2812_allOff() {
  WS2812_clearAll();
  debugPrintln("âš« WS2812 All OFF");
}

void WS2812_sweep(const CRGB* colors, uint8_t count) {
  debugPrintln("ðŸ” WS2812 Sweep with custom colors:");
  for (uint8_t i = 0; i < NUM_LEDS; ++i) {
    WS2812_clearAll();
    WS2812_setLEDColor(i, colors[i % count]);
    debugPrintf("ðŸŸ¢ LED %d ON with color: R=%d G=%d B=%d\n",
                i, colors[i % count].r, colors[i % count].g, colors[i % count].b);
    delay(400);
  }
  WS2812_clearAll();
  debugPrintln("âœ… WS2812 Sweep complete.");
}

void WS2812_testPattern() {
  const CRGB VZColors[] = { CRGB::Yellow, CRGB::Blue, CRGB::Red };
  debugPrintln("ðŸ§ª WS2812 Test Pattern Start");
  WS2812_allOff();
  WS2812_sweep(VZColors, sizeof(VZColors)/sizeof(CRGB));
  WS2812_allOn(CRGB::Green);
  debugPrintln("âœ… WS2812 Test Pattern Complete");
}

void WS2812_setAllLEDs(bool state) {
  WS2812_allOn(state ? CRGB::Green : CRGB::Black);
}
